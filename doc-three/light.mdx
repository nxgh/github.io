# Light

Three.js 中包含大量的光源，每一个光源都有特别的用法， 这一章会讲解不同光源的详情，并为下一章材质的使用做准备

| 光源             | 描述                                                                                                     | 阴影                         |
| :--------------- | :------------------------------------------------------------------------------------------------------- | :--------------------------- |
| AmbientLight     | 基本光源，该光源的颜色会叠加到场景现有物体的颜色上，会均匀的照亮场景中的所有物体                         | 不能投射阴影，因为它没有方向 |
| PointLight       | 点光源，从一个点向各个方向发射的光源，常见的例子是模拟一个电灯泡发出的光                                 | 可以投射阴影                 |
| SpotLight        | 聚光灯，光线从一个点沿一个方向射出，随着光线照射的变远，光线圆锥体的尺寸也逐渐增大                       | 可以投射阴影                 |
| DirectionalLight | 被称为平行光或无限光，这种光源发出的光线可以看作是平行的，就像太阳光                                     | 可以投射阴影                 |
| HemisphereLight  | 半球光，一种特殊的光源。光源直接放置在场景之上，光照颜色从天空光线颜色渐变到地面光线颜色。               | 不能投射阴影                 |
| RectAreaLight    | 平面光光源，平面光光源从一个矩形平面上均匀地发射光线。这种光源可以用来模拟像明亮的窗户或者条状灯光光源。 | 不能投射阴影                 |

<CH.Scrollycoding preset="https://codesandbox.io/s/7wt1zq">

我们在第一章的代码的基础上做一些改动

主要是添加一个带有马赛克纹理平面

```js src/index.js
// from ../data/three/light/s1.js
```

---

接着再添加一个立方体和一个球体, 一切准备就绪，我们开始添加光源

```js src/index.js
// from ../data/three/light/s2.js
```

---

## 环境光（AmbientLight）

环境光，它没有方向，无法产生阴影，场景内任何一点受到的光照强度都是相同的，除了改变场景内所有物体的颜色以外，不会使物体产生明暗的变化，看起来并不像真正意义上的光照。通常的作用是提亮场景，让暗部不要太暗。

```js src/index.js
// from ../data/three/light/s3.js
```

---

我们添加一些控制代码，使我们可以动态地改变光照的参数，还是使用 lil-gui 来实现,

首先，我们创建一个辅助对象。对象内有一个 getter 和 setter，当 lil-gui 从对象内获取 value 值的时候，触发了 getter，会根据创建对象实例时传入的 object 和 prop，返回一个十六进制色值的字符串，当通过
lil-gui 控制改变这个 value 的时候，就触发了 setter，会用十六进制的色值字符串作为参数调用 object.prop.set。

```js src/index.js
// from ../data/three/light/s4.js
```

---

创建 lil-gui

现在可以看到场景内的物体看起来没有立体感。环境光 （AmbientLight）只是简单地将材质的颜色与光照颜色进行叠加，再乘以光照强度

这就是环境光，它没有方向，无法产生阴影，场景内任何一点受到的光照强度都是相同的，除了改变场景内所有物体的颜色以外，不会使物体产生明暗的变化，看起来并不像真正意义上的光照。通常的作用是提亮场景，让暗部不
要太暗。

```js src/index.js
// from ../data/three/light/s5.js
```

---

## 半球光 HemisphereLight

半球光（HemisphereLight）的颜色是从天空到地面两个颜色之间的渐变，与物体材质的颜色作叠加后得到最终的颜色效果。一个点受到的光照颜色是由所在平面的朝向（法向量）决定的 —— 面向正上方就受到天空的光照颜色，
面向正下方就受到地面的光照颜色，其他角度则是两个颜色渐变区间的颜色。

场景基本上也没有太大的立体感。半球光 （HemisphereLight） 与其他类型光照结合使用，可以很好地表现天空和地面颜色照射到物体上时的效果。所以最好的使用场景就是与其他光照结合使用，或者作为环境光
（AmbientLight）的一种替代方案。

```js src/index.js
// from ../data/three/light/s6.js
```

---

## 方向光 DirectionalLight

方向光（DirectionalLight）常常用来表现太阳光照的效果。

```js src/index.js
// from ../data/three/light/s7.js
```

---

目前有点难以观察。Three.js 提供了一些辅助对象，添加到场景中之后就可以显示出场景中的不可见对象

在这里我们使用 DirectionalLightHelper，它会绘制一个方形的小平面代表方向光的位置，一条连接光源与目标点的直线，代表了光的方向。

```js src/index.js
// from ../data/three/light/s8.js
```

---

我们顺便实现一下对光源位置和目标点位置的控制逻辑。我们创建一个辅助函数，使得可以通过 lil-gui 改变传入的 Vector3 类型对象的 x，y，和 z 的值。

```js src/index.js
// from ../data/three/light/s9.js
```

---

注意，当辅助对象所表示的不可见对象有所改变的时候，我们必须调用辅助对象的 update 方法来更新辅助对象本身的状态。因此我们传入一个 onChangeFn 函数，每当 lil-gui 改变了某个值的时候，就会被调用。

现在我们可以控制光源以及目标点位置了。

```js src/index.js
// from ../data/three/light/s10.js
```

---

## 点光源（PointLight）

点光源（PointLight）表示的是从一个点朝各个方向发射出光线的一种光照效果

PointLightHelper 不是一个点，而是在光源的位置绘制了一个小小的线框宝石体来代表点光源。也可以使用其他形状来表示点光源，只要给点光源添加一个自定义的 Mesh 子节点即可。

点光源（PointLight）有额外的一个范围（distance）属性。 如果 distance 设为 0，则光线可以照射到无限远处。如果大于 0，则只可以照射到指定的范围，光照强度在这个过程中逐渐衰减，在光源位置时，intensity 是设
定的大小，在距离光源 distance 位置的时候，intensity 为 0。

```js src/index.js
// from ../data/three/light/s11.js
```

---

## 聚光灯（SpotLight）

聚光灯可以看成是一个点光源被一个圆锥体限制住了光照的范围。实际上有两个圆锥，内圆锥和外圆锥。光照强度在两个锥体之间从设定的强度递减到 0

内圆锥是通过设置 penumbra 属性来定义的，属性值代表了内圆锥相对外圆锥大小变化的百分比。当 penumbra 为 0 时，内圆锥大小与外圆锥大小一致；当 penumbra 为 1 时，内圆锥大小为 0，光照强度从中轴线就开始往外递
减；当 penumbra 为 0.5 时，光照强度从外圆锥半径的中点处开始往外递减。

当 penumbra 为默认值 0 的时候，聚光灯会有非常清晰的边缘，而当把 penumbra 向 1 调节的时候，边缘会开始模糊

```js src/index.js
// from ../data/three/light/s12.js
```

---

## 矩形区域光（RectAreaLight）

Three.js 中还有一种类型的光照，矩形区域光（RectAreaLight）, 顾名思义，表示一个矩形区域的发射出来的光照，例如长条的日光灯或者天花板上磨砂玻璃透进来的自然光。

RectAreaLight 只能影响 MeshStandardMaterial 和 MeshPhysicalMaterial，所以我们把所有的材质都改为 MeshStandardMaterial。

<CH.Section>```diff -const planeMat = new THREE.MeshPhongMaterial() +const planeMat = new THREE.MeshStandardMaterial() ```</CH.Section>

为了使用 RectAreaLight，我们需要引入 three.js 的 RectAreaLightUniformsLib 模块，同时使用 RectAreaLightHelper 来辅助查看灯光对象。

<CH.Section>

```js
import { RectAreaLightUniformsLib } from '/examples/jsm/lights/RectAreaLightUniformsLib.js'
import { RectAreaLightHelper } from '/examples/jsm/helpers/RectAreaLightHelper.js'
```

</CH.Section>

我们需要先调用 `RectAreaLightUniformsLib.init`

如果忘了引入和使用 RectAreaLightUniformsLib，光照还是可以显示，但是会看起来很奇怪，所以要确保有使用

需要注意的是，与方向光（DirectionalLight）和聚光灯（SpotLight）不同，矩形光不是使用目标点（target），而是使用自身的旋转角度来确定光照方向。另外，矩形光的辅助对象（RectAreaLightHelper）应该添加为光照的
子节点，而不是添加为场景的子节点

```js src/index.js
// from ../data/three/light/s13.js
```

---

## physicallyCorrectLights

WebGLRenderer 中有一个设置项 physicallyCorrectLights。这个设置会影响（随着离光源的距离增加）光照如何减弱。这个设置会影响点光源（PointLight）和聚光灯（SpotLight），矩形区域光（RectAreaLight）会自动应用
这个特性

在设置光照时，基本思路是不要设置 distance 来表现光照的衰减，也不要设置 intensity。而是设置光照的 power 属性，以流明为单位，three.js 会进行物理计算，从而表现出接近真实的光照效果。在这种情况下 three.js
参与计算的长度单位是米，一个 60 瓦 的灯泡大概是 800 流明强度。并且光源有一个 decay 属性，为了模拟真实效果，应该被设置为 2。


首先开启 physicallyCorrectLights 模式

<CH.Section>
```js 
renderer.physicallyCorrectLights = true;
```
</CH.Section>

然后我们设置光照的参数，power 设置为 800 流明，decay 设置为 2，distance 设置为 Infinity。


并且添加 gui 控制 power 和 decay

<CH.Section>
```js 
const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
gui.add(light, 'decay', 0, 4, 0.01);
gui.add(light, 'power', 0, 2000);
```
</CH.Section>

需要注意，每添加一个光源到场景中，都会降低 three.js 渲染场景的速度，所以应该尽量使用最少的资源来实现想要的效果。

```js src/index.js
// from ../data/three/light/s14.js
```



</CH.Scrollycoding>
