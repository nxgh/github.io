import AddGeometryS5 from '../data/three/fundamentals/s5.mdx'

## Hello Three.js

<CH.Scrollycoding preset="https://codesandbox.io/s/7wt1zq">

这是 Three.js 系列文章的第一篇, 原文主要来自 [Three.js 官方文档](https://threejs.org/docs), 这个系列
会用交互式代码来学习 Three.js

人们在学习大多数编程语言的时候第一件事就是让电脑打印个"Hello World!"。 对于三维来说第一件事往往是创
建一个三维的立方体。 所以我们从"Hello Cube!"开始。

在我们开始前，让我们先了解一个 three.js 应用的整体结构。一个 three.js 应用需要创建很多对象
，并且将他们关联在一起。下图是一个基础的 three.js 应用结构。

![Three.js应用结构](https://threejs.org/manual/resources/images/threejs-structure.svg)

```js src/index.js
import * as Three from 'three'

function main() {
  const app = document.querySelector('#app')
}

main()
```

---

## Renderer、Scene、Camera

<CH.Section>

第一步，我们要搭建一个空场景，这个空场景需要以下几个对象: Renderer、Scene、Camera

## Scene

场景(Scene)是 three.js 的基本的组成部分。需要 three.js 绘制的东西都需要加入到 scene 中。

```js
scene = new THREE.Scene()
```

</CH.Section>

```js src/index.js
import * as THREE from 'three'

function main() {
  // focus
  const scene = new THREE.Scene()

  const app = document.querySelector('#app')
}
main()
```

---

<CH.Section>

## Camera:

Three.js 中有几种不同的相机，这里使用的是 PerspectiveCamera (透视摄像机)。

```js
const fov = 75 // 视野范围
const aspect = 2 // 画布的宽高比
const near = 0.1 // 近平面
const far = 5 // 远平面
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
```

摄像机之后会详细讲解

</CH.Section>

```js src/index.js
import * as THREE from 'three'

const { innerWidth, innerHeight } = window

function main() {
  const scene = new THREE.Scene()
  // focus
  const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000)

  const app = document.querySelector('#app')
}

main()
```

---

<CH.Section>

## Renderer: 渲染器

Renderer 是 three.js 的主要对象。渲染器负责将你提供的所有数据渲染绘制到 canvas 上,目前的话是 WebGL
渲染器(WebGLRenderer)，它通过 WebGL 将三维空间渲染到 canvas 上

Three.js 同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持 WebGL 时，可
以使用这几种渲染器进行降级。

这里我们设置属性抗锯齿 `antialias` 为 true 

```js
renderer = new THREE.WebGLRenderer({ antialias: true })
```

</CH.Section>

```js src/index.js
import * as THREE from 'three'

const { innerWidth, innerHeight } = window

function main() {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000)
  // focus
  const renderer = new THREE.WebGLRenderer({ antialias: true })

  const app = document.querySelector('#app')
}

main()
```

---

<CH.Section>

你传入一个场景 (Scene)和一个摄像机(Camera)到渲染器(Renderer)中，然后它会将摄像机视椎体中的三维场景渲
染成一个二维图片显示在画布上。

```js
renderer.render(scene, camera)
```

</CH.Section>

<CH.Section>

我们还需要给渲染器设置一个尺寸,比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填
充满我们的应用程序

```js
renderer.setSize(window.innerWidth, window.innerHeight)
```

</CH.Section>

<CH.Section>

最后一步很重要，我们将 renderer（渲染器）的 dom 元素（renderer.domElement）添加到我们的 HTML 文档中
。这就是渲染器用来显示场景给我们看的 `<canvas>` 元素。

```js
app.appendChild(renderer.domElement)
```

</CH.Section>

```js src/index.js
import * as THREE from 'three'

const { innerWidth, innerHeight } = window

function main() {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000)

  const renderer = new THREE.WebGLRenderer({ antialias: true })
  // focus(1,2)
  renderer.setSize(innerWidth, innerHeight)
  renderer.render(scene, camera)

  const app = document.querySelector('#app')
  // focus
  app.appendChild(renderer.domElement)
}

main()
```

---

到目前为止，我们已经创建了空白的场景、渲染器和摄像机，但是还没有渲染任何东西。接下来，我们来添加一个
正方体

```js src/index.js
import * as THREE from 'three'
const { innerWidth, innerHeight } = window

function main() {
  // focus(1:8)
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000)
  const renderer = new THREE.WebGLRenderer({ antialias: true })
  renderer.setSize(innerWidth, innerHeight)
  renderer.render(scene, camera)

  const app = document.querySelector('#app')
  app.appendChild(renderer.domElement)
}

main()
```

---

<CH.Section>
要创建一个立方体，我们需要一个 `BoxGeometry`（立方体）对象. 这个对象包含了一个立方体中所有的顶点
（vertices）和面（faces）

```js
const boxWidth = 1
const boxHeight = 1
const boxDepth = 1
const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth)
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s1.js
```

---

<CH.Section>

对于这个立方体，我们需要给它一个材质，来让它有颜色, Three.js 自带了几种材质，在这里我们使用的是
`MeshBasicMaterial`

```js
const material = new THREE.MeshBasicMaterial({ color: 0x44aa88 })
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s2.js
```

---

<CH.Section>
第三步，我们需要一个 Mesh（网格） 对象, 它包含了：

1. 几何体(Geometry)(物体的形状)
2. 材质(Material)(如何绘制物体，光滑还是平整，什么颜色，什么贴图等等)
3. 对象在场景中相对于他父对象的位置、朝向、和缩放。下面的代码中父对象即为场景对象。

我们将网格添加到场景中。之后将场景和摄像机传递给渲染器来渲染出整个场景。

```js
const cube = new THREE.Mesh(geometry, material)
scene.add(cube)
renderer.render(scene, camera)
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s3.js
```

---

<CH.Section>
默认情况下，当我们调用 scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在
一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。

```js
camera.position.z = 5
```

</CH.Section>
```js src/index.js
// from ../data/three/fundamentals/s4.js
```

---

<AddGeometryS5 />

```js src/index.js
// from ../data/three/fundamentals/s5.js
```

---

<CH.Section>

在我们加上旋转之后效果好了一些,但还是很难看出是三维的。我们来添加一些光照效果，应该会有点帮助。

three.js 中有很多种类型的灯光，我们将在后期文章中详细讨论。现在我们先创建一盏 DirectionalLight (平行
光)。

```js
{
  const color = 0xffffff
  const intensity = 1
  const light = new THREE.DirectionalLight(color, intensity)
  light.position.set(-1, 2, 4)
  scene.add(light)
}
```

平行光有一个位置和目标点。默认值都为(0, 0, 0)。我们这里 将灯光的位置设为(-1, 2, 4)，让它位于摄像机前
面稍微左上方一点的地方。目标点还是(0, 0, 0)，让它朝向坐标原点方向。

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s6.js
```

---

<CH.Section>
现在立方体没有变化，是因为 MeshBasicMaterial 材质不会受到灯光的影响。我们将他改成会受灯光影响的
MeshPhongMaterial 材质。

```diff
- const material = new THREE.MeshBasicMaterial({color: 0x44aa88});  // 绿蓝色
+ const material = new THREE.MeshPhongMaterial({color: 0x44aa88});  // 绿蓝色
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s7.js
```

---

现在应该可以很清楚的看出是三维立方体了。

接下来我们将会在代码中添加

- 轨道控制器
- 坐标轴辅助与网格辅助
- 光源与阴影

```js src/index.js
// from ../data/three/fundamentals/s8.js
```

---

## 添加一个轨道控制器

<CH.Section>
在代码中修改摄像机的属性总是不便的，Three.js 提供了 OrbitControls（轨道控制器）可以使得相机围绕目标
进行轨道运动, 使用它的方式也非常简单

```js
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'

const controls = new OrbitControls(camera, renderer.domElement)
controls.update()
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s9.js
```

---

## 添加坐标轴辅助对象

<CH.Section>
使用 `AxesHelper` 可以简单模拟 3 个坐标轴的对象

- 红色代表 X 轴
- 绿色代表 Y 轴
- 蓝色代表 Z 轴.

```js
const axesHelper = new THREE.AxesHelper(5)
scene.add(axesHelper)
```

</CH.Section>
```js src/index.js
// from ../data/three/fundamentals/s10.js
```

---

## 添加坐标格辅助对象

<CH.Section>
  使用 `GridHelper` 添加坐标格辅助对象. 坐标格实际上是 2 维线数组.

```js
const size = 10
const divisions = 10

const gridHelper = new THREE.GridHelper(size, divisions)
scene.add(gridHelper)
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s11.js
```

---

## 添加一个平面

<CH.Section>

平面的创建分为两步来完成。首先，使用 THREE.PlaneGeometry(height, width) 来定义平面的大小, 之后通过创
建 Material 对象设置平面的外观

这里使用了 MeshLambertMaterial 对象, 它是一种非光泽表面的材质，没有镜面高光

```js
const mesh = new THREE.Mesh(
  new THREE.PlaneGeometry(10, 10),
  new THREE.MeshLambertMaterial({ color: 0xffffff })
)
```

</CH.Section>

<CH.Section>

在将平面添加到场景之前，还需要设置平面的位置：先将平面围绕 x 轴旋转 90 度，然后使用 position 属性来
定义其在场景中的位置

```js
mesh.rotation.x = -Math.PI / 2
scene.add(mesh)
```

</CH.Section>
<CH.Section>

最后我们把几何体的 y 轴坐标设置为 1

```js
cube.position.y = 1
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s12.js
```

---

## 添加一个光源辅助对象

<CH.Section>

在上边我们通过 DirectionalLight 对象定义光源并从位置(1, 2, 2)照射场景。我们可以使用
DirectionalLightHelper 来创建一个光源的辅助对象，它会绘制一个方形的小平面代表方向光的位置，一条连接
光源与目标点的直线，代表了光的方向

```js
const helper = new THREE.DirectionalLightHelper(light)
scene.add(helper)
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s13.js
```

---

## 添加阴影


<CH.Section>

由于渲染阴影需要耗费大量的计算资源，所以默认情况下 Three.js 中是不会渲染阴影的。为了渲染阴影效果，我
们需要进行如下设置

```js
renderer.shadowMap.enabled = true
```

这时候查看修改的效果，那么你将会发现还是没有任何区别，因为你还需要明确地指定哪个物体投射阴影、哪个物
体接受阴影

</CH.Section>
```js src/index.js
// from ../data/three/fundamentals/s14.js
```

---

<CH.Section>
设置地面上接受阴影

```js
mesh.receiveShadow = true
```

</CH.Section>

<CH.Section>
设置立方体在地面上投射阴影

```js
cube.castShadow = true
```

</CH.Section>

<CH.Section>

设置光源阴影，并不是所有的光源都能够产生阴影, 通过 DirectionalLight 定义的光源是能够产生阴影的。我们
只要将属性 castShadow 设置为 true 就可以将阴影渲染出来了

```js
light.castShadow = true
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s15.js
```

---

## 使用 GUI 简化试验流程

在本章最后，将会使用 three.js 中的 lil-gui 库为我们的示例添加用户操作界面, 使我们可以

- 控制灯光的位置
- 控制立方体的位置

你也可以使用其他的 GUI 库 ，例如 dat.GUI

<CH.Section>

lil-gui 会根据属性的数据类型选择适当的控制器,而 onChange 会在值改变时更新

```js
import { GUI } from 'three/addons/libs/lil-gui.module.min.js'

const settings = {}
{
  const settings = { x: 1, y: 1, z: 1 }
  const gui = new GUI()
  gui.add(settings, 'x', -4.5, 4.5, 0.5).onChange((v) => (cube.position.x = v)) // min, max, step
  gui.add(settings, 'y', -4.5, 4.5, 0.5).onChange((v) => (cube.position.y = v))
  gui.add(settings, 'z', -4.5, 4.5, 0.5).onChange((v) => (cube.position.z = v))
}
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s16.js
```

---

<CH.Section>
可以使用 addFolder 添加一个折叠面板对 GUI 中的属性进行分类

```js
const lightFolder = gui.addFolder('light')

lightFolder.add(settings, 'light x', -5, 5, 0.5).onChange((v) => updateLight('x', v))
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s17.js
```

---

## 添加帧数显示

最后我们介绍一个辅助库 State.js 这个库也是 Three.js 作者开发的，主要用于检测动画运行时的帧数。在动画

运行时，该库可以显示每秒渲染的帧数、每渲染一帧所花费的时间和内存占用量。

State.js 使用也非常简便

<CH.Section>

```js
import Stats from 'three/examples/jsm//libs/stats.module.js'

const stats = new Stats()
app.appendChild(stats.dom)

function render(time) {
  stats.update()
  // ...
}
```

</CH.Section>

```js src/index.js
// from ../data/three/fundamentals/s18.js
```

---

## 总结

在本章中展示了使用 Three.js 渲染场景时，首先需要做的是创建 THREE.Scene 对象，添加摄像机、光源和需要
渲染的物体；如何给场景添加阴影和动画效果；添加辅助库 lil-gui 和 stats.js 创建用户控制界面和快速获取
场景渲染时的帧数。


接下来我们将会进一步扩展这个示例


```js src/index.js
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js'
import Stats from 'three/examples/jsm//libs/stats.module.js'

const { innerWidth, innerHeight } = window

function main() {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000)
  const renderer = new THREE.WebGLRenderer({ antialias: true })
  renderer.setSize(innerWidth, innerHeight)
  renderer.shadowMap.enabled = true
  renderer.render(scene, camera)

  const app = document.querySelector('#app')
  app.appendChild(renderer.domElement)
  const stats = new Stats();
  app.appendChild(stats.dom);

  let cube
  {
    const boxWidth = 1
    const boxHeight = 1
    const boxDepth = 1
    const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth)
    const material = new THREE.MeshPhongMaterial({ color: 0x44aa88 })
    cube = new THREE.Mesh(geometry, material)
    cube.position.y = 1
    cube.castShadow = true
    scene.add(cube)
    renderer.render(scene, camera)
  }

  let light, helper
  {
    const color = 0xffffff
    const intensity = 1
    light = new THREE.DirectionalLight(color, intensity)
    light.position.set(1, 3, 3)
    light.castShadow = true
    light.shadow.mapSize = new THREE.Vector2(2048, 2048)
    scene.add(light)
    helper = new THREE.DirectionalLightHelper(light)
    scene.add(helper)
  }

  {
    const mesh = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 10),
      new THREE.MeshLambertMaterial({ color: 0xffffff })
    )
    mesh.receiveShadow = true
    mesh.rotation.x = -Math.PI / 2
    scene.add(mesh)
  }

  {
    const controls = new OrbitControls(camera, renderer.domElement)
    controls.update()
  }

  {
    const axesHelper = new THREE.AxesHelper(5)
    scene.add(axesHelper)
    const gridHelper = new THREE.GridHelper(10, 10)
    scene.add(gridHelper)
    camera.position.set(0, 3, 9)
  }

  {
    const settings = {
      type: true,
      'cube x': 1,
      'cube y': 1,
      'cube z': 1,

      'light x': 1,
      'light y': 1,
      'light z': 1,
    }
    const gui = new GUI()

    gui.add(settings, 'cube x', -4.5, 4.5, 0.5).onChange((v) => (cube.position.x = v)) 
    gui.add(settings, 'cube y', -4.5, 4.5, 0.5).onChange((v) => (cube.position.y = v))
    gui.add(settings, 'cube z', -4.5, 4.5, 0.5).onChange((v) => (cube.position.z = v))

    const lightFolder = gui.addFolder('light')
    function updateLight(axes, value) {
      light.position[axes] = value
      helper.update()
    }
    lightFolder.add(settings, 'light x', -5, 5, 0.5).onChange((v) => updateLight('x', v)) 
    lightFolder.add(settings, 'light y', 1, 5, 0.5).onChange((v) => updateLight('y', v)) 
    lightFolder.add(settings, 'light z', -4.5, 4.5, 0.5).onChange((v) => updateLight('z', v))
  }

  function render(time) {
    stats.update()
    renderer.render(scene, camera)
    requestAnimationFrame(render)
  }
  requestAnimationFrame(render)
}

main()
```

</CH.Scrollycoding>
