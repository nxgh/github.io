# 坐标系

<CH.Scrollycoding preset="https://codesandbox.io/s/7wt1zq">

我们的屏幕是二维的，而我们构建 Three.js 程序时往往使用的是三维坐标(世界坐标),三维坐标转化为屏幕坐标会经过多道矩阵变换，
而在其中 WebGL 替我们做了许多事情

二维坐标系一般默认为 x 轴朝右，y 轴朝上

而对于三维坐标系, 一般有两种习俗 **左手坐标系** 和**右手坐标系**

我们可以将 X Y Z 固定对应到 拇指 食指 中指 的顺序

![](/assets/axes/left-or-right-handed-coordinate.jpg)

Threejs 使用的是右手坐标系，这源于 opengl 默认情况下，也是右手坐标系。

在 WebGL 中，世界坐标系是以屏幕中心为原点(0, 0, 0)，且是始终不变的。你面对屏幕，你的右边是 x 正轴，上面是 y 正轴，屏幕指
向你的为 z 正轴。

还记得之前的 [AxesHelper](https://threejs.org/docs/index.html?q=axes#api/zh/helpers/AxesHelper) 对象吗，红色代表 X 轴.
绿色代表 Y 轴. 蓝色代表 Z 轴.

```js src/index.js
// from ./data/fundamentals/s10.js
```

---

[WebGL 坐标系基础（一）](https://juejin.cn/post/6890795086054260750)

在 WebGL 中存在很多类型的坐标:

- 模型坐标系(object space)
- 世界坐标系(world space)
- 观察坐标系(view space)
- 裁剪坐标系(clip space)
- 规范化的设备坐标系(NDC,normalized device coordinates)
- 屏幕坐标系(screen space)

各个坐标系都有其合适的场景，他们之间相对独立。但我们能通过坐标变换来将他们串联起来，最终的目的就是告诉计算机，我们要将一
个个的顶点绘制在屏幕的哪些位置

## 模型坐标系(object space)

模型坐标系就是一个基于模型本身的坐标系，用来描述模型的各个点分别在模型中的哪个位置，而不关心这个模型最终会被放在何处。这
个坐标系的原点一般在模型的正中心，当然也可以在别的地方，比如底部中心。

```js src/index.js
// from ./data/axes/object-space.js
```

---

## 世界坐标系(world space)

用来描述整个 3d 场景的坐标系，它的原点就是(0, 0, 0)点。我们将模型放在世界坐标系中，如果不进行变换，那么这个模型将会被放
在原点。

显然更多时候我们需要把模型放在世界坐标系原点以外的地方，那么这时候就需要进行变换。将模型坐标系转换到世界坐标系的变换，就
叫做**模型变换（model matrix）**。其中又包含旋转、缩放、平移三种基本变换

```js src/index.js
// from ./data/axes/world-space.js
```

---

## 观察坐标系(view space)

同一个世界，从不同的角度不同的位置观察，显然会看到不一样的东西。那么该如何描述这个角度与位置带来的影响呢？要解决这个问题
，我们需要引入观察坐标系。

观察坐标系（view space）又被称为相机坐标系（camera space）或者人眼坐标系（eye space）。它模拟了人眼/相机观察世界的结果，
以人眼/相机的位置为坐标原点，人眼/相机的方向为 z 轴正方向将世界坐标系经过视图变换（view matrix）就能转换到观察坐标系中。

如果我们的人眼/相机被安放在世界坐标系中的不同地方，朝向不同的方向，那么就会有不一样的视图变换矩阵，世界坐标系中的同一个
点，在观察坐标系中的坐标就会不一样。这样就模拟出人眼/相机在世界的不同位置不同方向观察世界，所得到的结果也不一样。

```js src/index.js
// from ./data/axes/view-space.js
```

---

## 裁剪坐标系(clip space)

不幸的是，我们屏幕是 2d 的，并且大小有限，无法容纳我们宽广的世界。这时候就需要用到裁剪坐标系。裁剪坐标系主要负责了两件事
：限制可视范围以及为后续将 3d 世界转成 2d 世界做准备。而要做到这两件事，我们首先需要定义一个可视范围，这个可视范围是我们
的投影变换矩阵定义的

投影变换矩阵是将观察坐标系转换到裁剪坐标系的投影变换所用到的矩阵，一般有两种：正交投影矩阵以及透视投影矩阵。在 Three.js
中便是透视投影摄像机(PerspectiveCamera)和正交投影摄像机(OrthographicCamera)

[摄像机](./camera)

```js src/index.js
// from ./data/camera/two-camera.js
```

---

## 规范化的设备坐标系与屏幕坐标系

- **规范化的设备坐标系（normalized device coordinates）**，顾名思义就是对坐标进行归一化处理。

我们的屏幕设备各种各样，我们需要一个统一的坐标系去描述我们的一个点需要渲染在屏幕的哪个位置，这个坐标系就是我们的 NDC

NDC 坐标系中的坐标当然不能直接用来绘制在屏幕上（NDC 坐标都在-1 到 1 之间），要绘制到屏幕上还需最后一个变换。

- **屏幕坐标系描** 述了真实的屏幕空间，将 NDC 坐标系转换到屏幕坐标系需要用到视口变换。

视口变换矩阵定义了屏幕坐标与 NDC 坐标的对应关系，不同分辨率的屏幕会有不同的视口变换矩阵

那么 **如何在 Three.js 中将世界坐标转换为屏幕坐标?** 通常是通过 `Vector3.project()`

- `Vector3.project(camera)`

  将此向量(坐标)从世界空间投影到相机的标准化设备坐标 (NDC) 空间

例如有立方体 cube, 获取 cube 的世界坐标就是

1. 获取网格模型的世界坐标

<CH.Section>

```js
const { x, y, z } = cube.position
const cubePos = new THREE.Vector3(x, y, z)
```

</CH.Section>

2. 世界坐标转化为标准坐标

Three.js 是使用了 canvas 绘制图形的，因此屏幕坐标系就是 canvas 中的坐标系，也就是左上角是坐标 原点

<img alt="" src="/assets/axes/canvas-and-three.png" width="50%" />

这里 canvas 画布的宽高分别是 `window.innerWidth` 和 `window.innerHeight`。从屏幕坐标系的角度看画布的中心坐标为

<CH.Section>

```js
const centerX = window.innerWidth / 2
const centerY = window.innerHeight / 2
```

</CH.Section>

然后，将设备坐标系使用 `Vector3.project` 方法转换到标准设备坐标系，

<CH.Section>
```js 
const standardVec3 = cubePos.project(camera)
```

</CH.Section>

3. 标准设备坐标转屏幕坐标

<CH.Section>

```js
// 标准设备坐标转屏幕坐标
const canvasX = Math.round(centerX _ standardVec3.x + centerX)
const canvasY = Math.round(-centerY _ standardVec3.y + centerY)
```

</CH.Section>

## 屏幕坐标转世界坐标

屏幕坐标转世界坐标便和上边步骤相反，即： 屏幕坐标 -> 标准设备坐标 -> 世界坐标系

假设 canvas 中有一点 (x, y), 那么这个点在空间坐标系的坐标便是

<CH.Section>

```js
const x1 = (x / width.innerWidth) * 2 - 1
const y1 = -(y / window.innerHeight) * 2 + 1
```

</CH.Section>
然后，再通过 Vector3.unproject(camera) 方法将标准设备坐标转为世界坐标

```js
const standardVec3 = new Vector3(x1, y1, 0)
const worldVector = standardVec3.unproject(camera)
```

<CH.Section>

```js src/index.js
// from ./data/axes/s2.js
```

</CH.Section>
</CH.Scrollycoding>
