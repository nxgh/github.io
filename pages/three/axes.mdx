# 坐标系

<CH.Scrollycoding preset="https://codesandbox.io/s/7wt1zq">

[WebGL 坐标系基础（一）](https://juejin.cn/post/6890795086054260750)

在 WebGL 中存在很多类型的坐标:

- 模型坐标系(object space)
- 世界坐标系(world space)
- 观察坐标系(view space)
- 裁剪坐标系(clip space)
- 规范化的设备坐标系(NDC,normalized device coordinates)
- 屏幕坐标系(screen space)

各个坐标系都有其合适的场景，他们之间相对独立。但我们能通过坐标变换来将他们串联起来，最终的目的就是告诉计算机，我们要将一
个个的顶点绘制在屏幕的哪些位置

## 模型坐标系(object space)

模型坐标系就是一个基于模型本身的坐标系，用来描述模型的各个点分别在模型中的哪个位置，而不关心这个模型最终会被放在何处。这
个坐标系的原点一般在模型的正中心，当然也可以在别的地方，比如底部中心。

```js src/index.js
// from ../../data/three/axes/object-space.js
```

---

## 世界坐标系(world space)

用来描述整个 3d 场景的坐标系，它的原点就是(0, 0, 0)点。我们将模型放在世界坐标系中，如果不进行变换，那么这个模型将会被放
在原点。

显然更多时候我们需要把模型放在世界坐标系原点以外的地方，那么这时候就需要进行变换。将模型坐标系转换到世界坐标系的变换，就
叫做**模型变换（model matrix）**。其中又包含旋转、缩放、平移三种基本变换

```js src/index.js
// from ../../data/three/axes/world-space.js
```

---

## 观察坐标系(view space)

同一个世界，从不同的角度不同的位置观察，显然会看到不一样的东西。那么该如何描述这个角度与位置带来的影响呢？要解决这个问题
，我们需要引入观察坐标系。

观察坐标系（view space）又被称为相机坐标系（camera space）或者人眼坐标系（eye space）。它模拟了人眼/相机观察世界的结果，
以人眼/相机的位置为坐标原点，人眼/相机的方向为 z 轴正方向将世界坐标系经过视图变换（view matrix）就能转换到观察坐标系中。

如果我们的人眼/相机被安放在世界坐标系中的不同地方，朝向不同的方向，那么就会有不一样的视图变换矩阵，世界坐标系中的同一个
点，在观察坐标系中的坐标就会不一样。这样就模拟出人眼/相机在世界的不同位置不同方向观察世界，所得到的结果是不一样的，这一
结果

```js src/index.js
// from ../../data/three/axes/view-space.js
```

---

- 裁剪坐标系(clip space)
- 规范化的设备坐标系(NDC,normalized device coordinates)
- 屏幕坐标系(screen space)

我们的屏幕是二维的，而我们构建 Three.js 程序时往往使用的是三维坐标(世界坐标),三维坐标转化为屏幕坐标会经过多道矩阵变换，
而在其中 WebGL 替我们做了许多事情

二维坐标系一般默认为 x 轴朝右，y 轴朝上

而对于三维坐标系, 一般有两种习俗 **左手坐标系** 和**右手坐标系**

我们可以将 X Y Z 固定对应到 拇指 食指 中指 的顺序

![](/assets/axes/left-or-right-handed-coordinate.jpg)

Threejs 使用的是右手坐标系，这源于 opengl 默认情况下，也是右手坐标系。

在 WebGL 中，世界坐标系是以屏幕中心为原点(0, 0, 0)，且是始终不变的。你面对屏幕，你的右边是 x 正轴，上面是 y 正轴，屏幕指
向你的为 z 正轴。

还记得之前的 [AxesHelper](https://threejs.org/docs/index.html?q=axes#api/zh/helpers/AxesHelper) 对象吗，红色代表 X 轴.
绿色代表 Y 轴. 蓝色代表 Z 轴.

```js src/index.js
// from ../../data/three/fundamentals/s10.js
```

---

</CH.Scrollycoding>
